#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stdint.h>
#include <sys/mman.h>

// Define a function pointer type for ASM segments.
typedef void (*asm_segment_t)(void);

// --- Helper Functions to Encode Instructions --- //
// All instructions are 32-bit. We assume 64-bit (AArch64) registers.
// Registers: values 0â€“31. Immediate values are chosen in valid ranges.

// 1. Encode ADD (immediate) instruction.
//    Format: ADD Xd, Xn, #imm12
//    Opcode base for 64-bit ADD immediate: 0x91000000.
uint32_t encode_add_imm(void) {
    uint32_t rd = rand() % 32;
    uint32_t rn = rand() % 32;
    uint32_t imm12 = rand() % 4096;  // 12-bit immediate: 0..4095
    return 0x91000000 | ((imm12 & 0xFFF) << 10) | ((rn & 0x1F) << 5) | (rd & 0x1F);
}

// 2. Encode SUB (immediate) instruction.
//    Format: SUB Xd, Xn, #imm12
//    Opcode base for 64-bit SUB immediate: 0xD1000000.
uint32_t encode_sub_imm(void) {
    uint32_t rd = rand() % 32;
    uint32_t rn = rand() % 32;
    uint32_t imm12 = rand() % 4096;
    return 0xD1000000 | ((imm12 & 0xFFF) << 10) | ((rn & 0x1F) << 5) | (rd & 0x1F);
}

// 3. Encode MOVZ (move wide with zero) instruction.
//    Format: MOVZ Xd, #imm16, LSL #(shift)
//    Opcode base for MOVZ: 0xD2800000.
//    Valid shifts (in bits): 0, 16, 32, 48.
uint32_t encode_movz(void) {
    uint32_t rd = rand() % 32;
    uint32_t imm16 = rand() % 0x10000; // 16-bit immediate
    // Choose a shift factor: one of {0, 16, 32, 48}.
    uint32_t shifts[4] = {0, 16, 32, 48};
    uint32_t shift = shifts[rand() % 4];
    // In the instruction, shift is encoded as (shift/16) in bits [22:21].
    uint32_t shift_field = (shift / 16) & 0x3;
    return 0xD2800000 | ((imm16 & 0xFFFF) << 5) | (rd & 0x1F) | (shift_field << 21);
}

// 4. Encode MOVK (move wide with keep) instruction.
//    Format: MOVK Xd, #imm16, LSL #(shift)
//    Opcode base for MOVK: 0xF2800000.
uint32_t encode_movk(void) {
    uint32_t rd = rand() % 32;
    uint32_t imm16 = rand() % 0x10000;
    uint32_t shifts[4] = {0, 16, 32, 48};
    uint32_t shift = shifts[rand() % 4];
    uint32_t shift_field = (shift / 16) & 0x3;
    return 0xF2800000 | ((imm16 & 0xFFFF) << 5) | (rd & 0x1F) | (shift_field << 21);
}

// 5. Encode an AND (register) instruction.
//    Format: AND Xd, Xn, Xm
//    A simplified encoding using a base constant.
//    Here we use: 0x8A000000 as base, then encode: rm in bits [20:16], rn in bits [9:5], rd in bits [4:0].
uint32_t encode_and_reg(void) {
    uint32_t rd = rand() % 32;
    uint32_t rn = rand() % 32;
    uint32_t rm = rand() % 32;
    return 0x8A000000 | ((rm & 0x1F) << 16) | ((rn & 0x1F) << 5) | (rd & 0x1F);
}

// 6. Encode an ORR (register) instruction.
//    Format: ORR Xd, Xn, Xm
//    Base opcode: 0xAA000000.
uint32_t encode_orr_reg(void) {
    uint32_t rd = rand() % 32;
    uint32_t rn = rand() % 32;
    uint32_t rm = rand() % 32;
    return 0xAA000000 | ((rm & 0x1F) << 16) | ((rn & 0x1F) << 5) | (rd & 0x1F);
}

// 7. Encode an EOR (register) instruction.
//    Format: EOR Xd, Xn, Xm
//    Base opcode: 0xCA000000.
uint32_t encode_eor_reg(void) {
    uint32_t rd = rand() % 32;
    uint32_t rn = rand() % 32;
    uint32_t rm = rand() % 32;
    return 0xCA000000 | ((rm & 0x1F) << 16) | ((rn & 0x1F) << 5) | (rd & 0x1F);
}

// 8. Encode a NOP instruction (no operation).
//    NOP is fixed at: 0xD503201F.
uint32_t encode_nop(void) {
    return 0xD503201F;
}

// --- Advanced Random Segment Generator --- //

/*
 * generate_random_segment_advanced:
 *
 * Allocates an executable memory buffer and fills it with a random sequence
 * of up to 'max_instructions' instructions. The sequence is generated by randomly
 * choosing among several instruction types (ADD immediate, SUB immediate, MOVZ,
 * MOVK, AND (reg), ORR (reg), EOR (reg), NOP). The buffer is terminated with a RET
 * instruction (0xD65F03C0) so that it can be executed safely.
 *
 * 'max_instructions' should be a value up to 200.
 *
 * Returns a function pointer (of type asm_segment_t) that can be executed.
 */
asm_segment_t generate_random_segment_advanced(int max_instructions) {
    if (max_instructions > 200) {
        max_instructions = 200; // enforce maximum limit
    }
    // Choose a random number of instructions between 1 and max_instructions.
    int num_instructions = (rand() % max_instructions) + 1;
    size_t code_size = (num_instructions + 1) * sizeof(uint32_t); // +1 for RET

    // Allocate an executable memory buffer.
    void *mem = mmap(NULL, code_size, PROT_READ | PROT_WRITE | PROT_EXEC,
                     MAP_ANON | MAP_PRIVATE, -1, 0);
    if (mem == MAP_FAILED) {
        perror("mmap");
        exit(EXIT_FAILURE);
    }

    uint32_t *code = (uint32_t *)mem;

    // There are 8 types of instructions we can generate.
    for (int i = 0; i < num_instructions; i++) {
        int type = rand() % 8;
        switch (type) {
            case 0:
                code[i] = encode_add_imm();
                break;
            case 1:
                code[i] = encode_sub_imm();
                break;
            case 2:
                code[i] = encode_movz();
                break;
            case 3:
                code[i] = encode_movk();
                break;
            case 4:
                code[i] = encode_and_reg();
                break;
            case 5:
                code[i] = encode_orr_reg();
                break;
            case 6:
                code[i] = encode_eor_reg();
                break;
            case 7:
            default:
                code[i] = encode_nop();
                break;
        }
    }
    // Append the RET instruction at the end.
    // For AArch64, RET is encoded as: 0xD65F03C0.
    code[num_instructions] = 0xD65F03C0;

    return (asm_segment_t)mem;
}

// --- Main Function --- //

int main(void) {
    // Seed the random number generator.
    srand((unsigned)time(NULL));

    // Generate a random segment using up to 200 instructions.
    printf("Generating a random advanced ASM segment (up to 200 instructions)...\n");
    asm_segment_t random_seg = generate_random_segment_advanced(200);
    
    // Execute the generated segment.
    // (The instructions operate on random registers and immediates.
    //  Their results are not used; the focus is on exercising many base opcodes.)
    random_seg();

    printf("Random ASM segment executed.\n");

    return 0;
}
